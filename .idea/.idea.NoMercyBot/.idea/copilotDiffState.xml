<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/NoMercyBot.Api/Controllers/AuthController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/NoMercyBot.Api/Controllers/AuthController.cs" />
              <option name="originalContent" value="using Microsoft.AspNetCore.Http;&#10;using Microsoft.AspNetCore.Mvc;&#10;using NoMercyBot.Api.Helpers;&#10;using NoMercyBot.Database.Models;&#10;using NoMercyBot.Services.Discord;&#10;using NoMercyBot.Services.Interfaces;&#10;using NoMercyBot.Services.Obs;&#10;using NoMercyBot.Services.Spotify;&#10;using NoMercyBot.Services.Twitch;&#10;using NoMercyBot.Services.Twitch.Dto;&#10;&#10;namespace NoMercyBot.Api.Controllers;&#10;&#10;[ApiController]&#10;[Tags(&quot;Auth&quot;)]&#10;[Route(&quot;api/oauth/{provider}&quot;)]&#10;public class AuthController : BaseController&#10;{&#10;    private readonly Dictionary&lt;string, IAuthService&gt; _authServices;&#10;    &#10;    public AuthController(&#10;        [FromServices] TwitchAuthService twitchAuthService,&#10;        [FromServices] SpotifyAuthService spotifyAuthService,&#10;        [FromServices] DiscordAuthService discordAuthService,&#10;        [FromServices] ObsAuthService obsAuthService&#10;    )&#10;    {&#10;        _authServices = new()&#10;        {&#10;            [&quot;twitch&quot;] = twitchAuthService,&#10;            [&quot;spotify&quot;] = spotifyAuthService,&#10;            [&quot;discord&quot;] = discordAuthService,&#10;            [&quot;obs&quot;] = obsAuthService,&#10;        };&#10;    }&#10;&#10;    private IActionResult GetAuthService([FromRoute] string provider, out IAuthService? service)&#10;    {&#10;        service = null;&#10;&#10;        if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;        {&#10;            return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;        }&#10;&#10;        if (!foundService.Service.Enabled)&#10;        {&#10;            return ServiceUnavailableResponse($&quot;Provider '{provider}' is not enabled&quot;);&#10;        }&#10;&#10;        service = foundService;&#10;        return Ok();&#10;    }&#10;&#10;    // get a redirect url for the user to login directly to twitch&#10;    [HttpGet(&quot;login&quot;)]&#10;    public IActionResult Login([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;            &#10;            string authorizationUrl = authService!.GetRedirectUrl();&#10;&#10;            return Redirect(authorizationUrl);&#10;        } &#10;        catch (Exception e)&#10;        {&#10;            return BadRequestResponse(e.Message);&#10;        }&#10;    }&#10;    &#10;    [HttpGet(&quot;authorize&quot;)]&#10;    public async Task&lt;IActionResult&gt; Authorize([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            DeviceCodeResponse result = await authService!.Authorize();&#10;            return Ok(result);&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Authorize is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to authorize: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;redirect&quot;)]&#10;    public IActionResult RedirectUrl([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            string redirectUrl = authService!.GetRedirectUrl();&#10;            return Ok(new { url = redirectUrl });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;RedirectUrl is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to get redirect URL: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;callback&quot;)]&#10;    [HttpPost(&quot;callback&quot;)]&#10;    public async Task&lt;IActionResult&gt; Callback([FromRoute] string provider, [FromQuery] string code)&#10;    {&#10;        try&#10;        {&#10;            if (string.IsNullOrEmpty(code))&#10;            {&#10;                return BadRequestResponse(&quot;Authorization code is required&quot;);&#10;            }&#10;&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            (User, TokenResponse) tokenResponse = await authService!.Callback(code);&#10;            &#10;            return Ok(new&#10;            {&#10;                Message = &quot;Moderator logged in successfully&quot;,&#10;                User = new UserWithTokenDto(tokenResponse.Item1, tokenResponse.Item2),&#10;            });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Callback is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse(ex.Message);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;validate&quot;)]&#10;    public async Task&lt;IActionResult&gt; Validate([FromRoute] string provider, [FromBody] TokenRequest request)&#10;    {&#10;        User? currentUser = User.User();&#10;        if (currentUser is null) return UnauthenticatedResponse(&quot;User not logged in.&quot;);&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            (User, TokenResponse) result = await authService!.ValidateToken(request.AccessToken);&#10;            &#10;            return Ok(new&#10;            {&#10;                Message = &quot;Session validated successfully&quot;,&#10;                User = new UserWithTokenDto(currentUser, result.Item2),&#10;            });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Validate is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to validate token: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;refresh&quot;)]&#10;    public async Task&lt;IActionResult&gt; Refresh([FromRoute] string provider, [FromBody] TokenRequest request)&#10;    {&#10;        User? currentUser = User.User();&#10;        if (currentUser is null) return UnauthenticatedResponse(&quot;User not logged in.&quot;);&#10;        &#10;        try&#10;        {&#10;            if (string.IsNullOrEmpty(request.RefreshToken))&#10;            {&#10;                return BadRequestResponse(&quot;Refresh token is required&quot;);&#10;            }&#10;&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            (User, TokenResponse) result = await authService!.RefreshToken(request.RefreshToken);&#10;            &#10;            return Ok(new&#10;            {&#10;                Message = &quot;Token refreshed successfully&quot;,&#10;                User = new UserWithTokenDto(currentUser, result.Item2),&#10;            });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Refresh is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to refresh token: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;revoke&quot;)]&#10;    public async Task&lt;IActionResult&gt; Revoke([FromRoute] string provider, [FromBody] TokenRequest request)&#10;    {&#10;        try&#10;        {&#10;            if (string.IsNullOrEmpty(request.AccessToken))&#10;            {&#10;                return BadRequestResponse(&quot;Access token is required&quot;);&#10;            }&#10;&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            await authService!.RevokeToken(request.AccessToken);&#10;            return Ok(new { success = true });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Revoke is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to revoke token: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;config-status&quot;)]&#10;    public IActionResult GetProviderConfigStatus([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;            {&#10;                return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;            }&#10;            &#10;            bool isConfigured = false;&#10;            &#10;            try&#10;            {&#10;                isConfigured = foundService.Service is&#10;                {&#10;                    Enabled: true,&#10;                    ClientId: not null,&#10;                    ClientSecret: not null,&#10;                    Scopes.Length: &gt; 0&#10;                };&#10;            }&#10;            catch (InvalidOperationException)&#10;            {&#10;                // Configuration is missing&#10;            }&#10;            &#10;            return Ok(new&#10;            {&#10;                isConfigured,&#10;                foundService.Service.Name,&#10;                foundService.Service.Enabled,&#10;                foundService.Service.ClientId,&#10;                foundService.Service.ClientSecret,&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Error checking provider configuration: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;configure&quot;)]&#10;    public async Task&lt;IActionResult&gt; ConfigureProvider([FromRoute] string provider, [FromBody] ProviderConfigRequest request)&#10;    {&#10;        try&#10;        {&#10;            if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;            {&#10;                return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;            }&#10;&#10;            bool result = await foundService.ConfigureService(request);&#10;            &#10;            if (!result)&#10;            {&#10;                return BadRequestResponse(&quot;Failed to configure the provider&quot;);&#10;            }&#10;            &#10;            return Ok(new { success = true, message = $&quot;{provider} provider configured successfully&quot; });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Error configuring provider: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;scopes&quot;)]&#10;    public IActionResult GetAvailableScopes([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;            {&#10;                return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;            }&#10;            &#10;            return Ok(foundService.AvailableScopes);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Error retrieving available scopes: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [NonAction]&#10;    [HttpGet(&quot;bot/login&quot;)]&#10;    public IActionResult BotLogin()&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(&quot;twitch&quot;, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            string authorizationUrl = authService!.GetRedirectUrl();&#10;&#10;            return Redirect(authorizationUrl);&#10;        } &#10;        catch (Exception e)&#10;        {&#10;            return BadRequestResponse(e.Message);&#10;        }&#10;    }&#10;&#10;    [NonAction]&#10;    [HttpGet(&quot;bot-popup&quot;)]&#10;    public IActionResult BotPopupLogin()&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(&quot;twitch&quot;, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            // Get the redirect URL with force_verify to ensure a fresh login&#10;            string authorizationUrl = authService!.GetRedirectUrl();&#10;            &#10;            // Add special parameters for the popup flow&#10;            authorizationUrl += &quot;&amp;prompt=consent&amp;response_type=code&amp;force_verify=true&quot;;&#10;&#10;            return Redirect(authorizationUrl);&#10;        } &#10;        catch (Exception e)&#10;        {&#10;            return BadRequestResponse(e.Message);&#10;        }&#10;    }&#10;}&#10;&#10;public class TokenRequest&#10;{&#10;    public string AccessToken { get; set; } = string.Empty;&#10;    public string RefreshToken { get; set; } = string.Empty;&#10;}&#10;" />
              <option name="updatedContent" value="using Microsoft.AspNetCore.Http;&#10;using Microsoft.AspNetCore.Mvc;&#10;using NoMercyBot.Api.Helpers;&#10;using NoMercyBot.Database.Models;&#10;using NoMercyBot.Services.Discord;&#10;using NoMercyBot.Services.Interfaces;&#10;using NoMercyBot.Services.Obs;&#10;using NoMercyBot.Services.Spotify;&#10;using NoMercyBot.Services.Twitch;&#10;using NoMercyBot.Services.Twitch.Dto;&#10;&#10;namespace NoMercyBot.Api.Controllers;&#10;&#10;[ApiController]&#10;[Tags(&quot;Auth&quot;)]&#10;[Route(&quot;api/oauth/{provider}&quot;)]&#10;public class AuthController : BaseController&#10;{&#10;    private readonly Dictionary&lt;string, IAuthService&gt; _authServices;&#10;    &#10;    public AuthController(&#10;        [FromServices] TwitchAuthService twitchAuthService,&#10;        [FromServices] SpotifyAuthService spotifyAuthService,&#10;        [FromServices] DiscordAuthService discordAuthService,&#10;        [FromServices] ObsAuthService obsAuthService&#10;    )&#10;    {&#10;        _authServices = new()&#10;        {&#10;            [&quot;twitch&quot;] = twitchAuthService,&#10;            [&quot;spotify&quot;] = spotifyAuthService,&#10;            [&quot;discord&quot;] = discordAuthService,&#10;            [&quot;obs&quot;] = obsAuthService,&#10;        };&#10;    }&#10;&#10;    private IActionResult GetAuthService([FromRoute] string provider, out IAuthService? service)&#10;    {&#10;        service = null;&#10;&#10;        if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;        {&#10;            return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;        }&#10;&#10;        if (!foundService.Service.Enabled)&#10;        {&#10;            return ServiceUnavailableResponse($&quot;Provider '{provider}' is not enabled&quot;);&#10;        }&#10;&#10;        service = foundService;&#10;        return Ok();&#10;    }&#10;&#10;    // get a redirect url for the user to login directly to twitch&#10;    [HttpGet(&quot;login&quot;)]&#10;    public IActionResult Login([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;            &#10;            string authorizationUrl = authService!.GetRedirectUrl();&#10;&#10;            return Redirect(authorizationUrl);&#10;        } &#10;        catch (Exception e)&#10;        {&#10;            return BadRequestResponse(e.Message);&#10;        }&#10;    }&#10;    &#10;    [HttpGet(&quot;authorize&quot;)]&#10;    public async Task&lt;IActionResult&gt; Authorize([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            DeviceCodeResponse result = await authService!.Authorize();&#10;            return Ok(result);&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Authorize is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to authorize: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;redirect&quot;)]&#10;    public IActionResult RedirectUrl([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            string redirectUrl = authService!.GetRedirectUrl();&#10;            return Ok(new { url = redirectUrl });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;RedirectUrl is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to get redirect URL: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;callback&quot;)]&#10;    [HttpPost(&quot;callback&quot;)]&#10;    public async Task&lt;IActionResult&gt; Callback([FromRoute] string provider, [FromQuery] string code)&#10;    {&#10;        try&#10;        {&#10;            if (string.IsNullOrEmpty(code))&#10;            {&#10;                return BadRequestResponse(&quot;Authorization code is required&quot;);&#10;            }&#10;&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            (User user, TokenResponse tokenResponse) = await authService!.Callback(code);&#10;&#10;            // Prevent overwriting provider with wrong user&#10;            var existingUserId = authService.Service.UserId;&#10;            if (!string.IsNullOrEmpty(existingUserId) &amp;&amp; existingUserId != user.Id)&#10;            {&#10;                return Forbid(&quot;This provider is already linked to a different user. Please log out first or contact an admin.&quot;);&#10;            }&#10;&#10;            return Ok(new&#10;            {&#10;                Message = &quot;Moderator logged in successfully&quot;,&#10;                User = new UserWithTokenDto(user, tokenResponse),&#10;            });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Callback is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse(ex.Message);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;validate&quot;)]&#10;    public async Task&lt;IActionResult&gt; Validate([FromRoute] string provider, [FromBody] TokenRequest request)&#10;    {&#10;        User? currentUser = User.User();&#10;        if (currentUser is null) return UnauthenticatedResponse(&quot;User not logged in.&quot;);&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            (User, TokenResponse) result = await authService!.ValidateToken(request.AccessToken);&#10;            &#10;            return Ok(new&#10;            {&#10;                Message = &quot;Session validated successfully&quot;,&#10;                User = new UserWithTokenDto(currentUser, result.Item2),&#10;            });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Validate is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to validate token: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;refresh&quot;)]&#10;    public async Task&lt;IActionResult&gt; Refresh([FromRoute] string provider, [FromBody] TokenRequest request)&#10;    {&#10;        User? currentUser = User.User();&#10;        if (currentUser is null) return UnauthenticatedResponse(&quot;User not logged in.&quot;);&#10;        &#10;        try&#10;        {&#10;            if (string.IsNullOrEmpty(request.RefreshToken))&#10;            {&#10;                return BadRequestResponse(&quot;Refresh token is required&quot;);&#10;            }&#10;&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            (User, TokenResponse) result = await authService!.RefreshToken(request.RefreshToken);&#10;            &#10;            return Ok(new&#10;            {&#10;                Message = &quot;Token refreshed successfully&quot;,&#10;                User = new UserWithTokenDto(currentUser, result.Item2),&#10;            });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Refresh is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to refresh token: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;revoke&quot;)]&#10;    public async Task&lt;IActionResult&gt; Revoke([FromRoute] string provider, [FromBody] TokenRequest request)&#10;    {&#10;        try&#10;        {&#10;            if (string.IsNullOrEmpty(request.AccessToken))&#10;            {&#10;                return BadRequestResponse(&quot;Access token is required&quot;);&#10;            }&#10;&#10;            IActionResult serviceResult = GetAuthService(provider, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            await authService!.RevokeToken(request.AccessToken);&#10;            return Ok(new { success = true });&#10;        }&#10;        catch (NotImplementedException)&#10;        {&#10;            return NotImplementedResponse($&quot;Revoke is not implemented for provider '{provider}'&quot;);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Failed to revoke token: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;config-status&quot;)]&#10;    public IActionResult GetProviderConfigStatus([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;            {&#10;                return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;            }&#10;            &#10;            bool isConfigured = false;&#10;            &#10;            try&#10;            {&#10;                isConfigured = foundService.Service is&#10;                {&#10;                    Enabled: true,&#10;                    ClientId: not null,&#10;                    ClientSecret: not null,&#10;                    Scopes.Length: &gt; 0&#10;                };&#10;            }&#10;            catch (InvalidOperationException)&#10;            {&#10;                // Configuration is missing&#10;            }&#10;            &#10;            return Ok(new&#10;            {&#10;                isConfigured,&#10;                foundService.Service.Name,&#10;                foundService.Service.Enabled,&#10;                foundService.Service.ClientId,&#10;                foundService.Service.ClientSecret,&#10;            });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Error checking provider configuration: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpPost(&quot;configure&quot;)]&#10;    public async Task&lt;IActionResult&gt; ConfigureProvider([FromRoute] string provider, [FromBody] ProviderConfigRequest request)&#10;    {&#10;        try&#10;        {&#10;            if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;            {&#10;                return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;            }&#10;&#10;            bool result = await foundService.ConfigureService(request);&#10;            &#10;            if (!result)&#10;            {&#10;                return BadRequestResponse(&quot;Failed to configure the provider&quot;);&#10;            }&#10;            &#10;            return Ok(new { success = true, message = $&quot;{provider} provider configured successfully&quot; });&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Error configuring provider: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [HttpGet(&quot;scopes&quot;)]&#10;    public IActionResult GetAvailableScopes([FromRoute] string provider)&#10;    {&#10;        try&#10;        {&#10;            if (!_authServices.TryGetValue(provider.ToLower(), out IAuthService? foundService))&#10;            {&#10;                return NotFoundResponse($&quot;Provider '{provider}' not found&quot;);&#10;            }&#10;            &#10;            return Ok(foundService.AvailableScopes);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            return InternalServerErrorResponse($&quot;Error retrieving available scopes: {ex.Message}&quot;);&#10;        }&#10;    }&#10;&#10;    [NonAction]&#10;    [HttpGet(&quot;bot/login&quot;)]&#10;    public IActionResult BotLogin()&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(&quot;twitch&quot;, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            string authorizationUrl = authService!.GetRedirectUrl();&#10;&#10;            return Redirect(authorizationUrl);&#10;        } &#10;        catch (Exception e)&#10;        {&#10;            return BadRequestResponse(e.Message);&#10;        }&#10;    }&#10;&#10;    [NonAction]&#10;    [HttpGet(&quot;bot-popup&quot;)]&#10;    public IActionResult BotPopupLogin()&#10;    {&#10;        try&#10;        {&#10;            IActionResult serviceResult = GetAuthService(&quot;twitch&quot;, out IAuthService? authService);&#10;            if (serviceResult is not OkResult) return serviceResult;&#10;&#10;            // Get the redirect URL with force_verify to ensure a fresh login&#10;            string authorizationUrl = authService!.GetRedirectUrl();&#10;            &#10;            // Add special parameters for the popup flow&#10;            authorizationUrl += &quot;&amp;prompt=consent&amp;response_type=code&amp;force_verify=true&quot;;&#10;&#10;            return Redirect(authorizationUrl);&#10;        } &#10;        catch (Exception e)&#10;        {&#10;            return BadRequestResponse(e.Message);&#10;        }&#10;    }&#10;}&#10;&#10;public class TokenRequest&#10;{&#10;    public string AccessToken { get; set; } = string.Empty;&#10;    public string RefreshToken { get; set; } = string.Empty;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/NoMercyBot.Api/Controllers/ConfigController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/NoMercyBot.Api/Controllers/ConfigController.cs" />
              <option name="originalContent" value="using Microsoft.AspNetCore.Mvc;&#10;using NoMercyBot.Globals.Information;&#10;using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using NoMercyBot.Api.Helpers;&#10;&#10;namespace NoMercyBot.Api.Controllers&#10;{&#10;    [ApiController]&#10;    [Route(&quot;api/[controller]&quot;)]&#10;    public class ConfigController : ControllerBase&#10;    {&#10;        [HttpGet]&#10;        public IActionResult GetConfig()&#10;        {&#10;            var config = new&#10;            {&#10;                Config.DnsServer,&#10;                Config.UserAgent,&#10;                Config.InternalServerPort,&#10;                Config.InternalClientPort,&#10;                Config.Swagger,&#10;                Config.QueueWorkers,&#10;                Config.CronWorkers,&#10;                Config.UseTts,&#10;                Config.SaveTtsToDisk,&#10;                Config.UseFrankerfacezEmotes,&#10;                Config.UseBttvEmotes,&#10;                Config.UseSevenTvEmotes,&#10;                Config.UseChatCodeSnippets,&#10;                Config.UseChatHtmlParser,&#10;                Config.UseChatOgParser&#10;            };&#10;            return Ok(config);&#10;        }&#10;&#10;        public class ConfigUpdateRequest&#10;        {&#10;            public int? QueueWorkers { get; set; }&#10;            public int? CronWorkers { get; set; }&#10;            public bool? UseTts { get; set; }&#10;            public bool? SaveTtsToDisk { get; set; }&#10;            public bool? UseFrankerfacezEmotes { get; set; }&#10;            public bool? UseBttvEmotes { get; set; }&#10;            public bool? UseSevenTvEmotes { get; set; }&#10;            public bool? UseChatCodeSnippets { get; set; }&#10;            public bool? UseChatHtmlParser { get; set; }&#10;            public bool? UseChatOgParser { get; set; }&#10;        }&#10;&#10;        [HttpPut]&#10;        public async Task&lt;IActionResult&gt; UpdateConfig([FromBody] ConfigUpdateRequest request)&#10;        {&#10;            int userId = User.UserId();&#10;            &#10;            if (request.QueueWorkers is not null)&#10;            {&#10;                Config.QueueWorkers = new(Config.QueueWorkers.Key, (int)request.QueueWorkers);&#10;                // await QueueRunner.SetWorkerCount(Config.QueueWorkers.Key, (int)request.QueueWorkers, userId);&#10;            }&#10;            if (request.CronWorkers is not null)&#10;            {&#10;                Config.CronWorkers = new(Config.CronWorkers.Key, (int)request.CronWorkers);&#10;                // await QueueRunner.SetWorkerCount(Config.CronWorkers.Key, (int)request.CronWorkers, userId);&#10;            }&#10;            &#10;            if (request.UseTts is not null)&#10;                Config.UseTts = request.UseTts.Value;&#10;            if (request.SaveTtsToDisk is not null)&#10;                Config.SaveTtsToDisk = request.SaveTtsToDisk.Value;&#10;            if (request.UseFrankerfacezEmotes is not null)&#10;                Config.UseFrankerfacezEmotes = request.UseFrankerfacezEmotes.Value;&#10;            if (request.UseBttvEmotes is not null)&#10;                Config.UseBttvEmotes = request.UseBttvEmotes.Value;&#10;            if (request.UseSevenTvEmotes is not null)&#10;                Config.UseSevenTvEmotes = request.UseSevenTvEmotes.Value;&#10;            if (request.UseChatCodeSnippets is not null)&#10;                Config.UseChatCodeSnippets = request.UseChatCodeSnippets.Value;&#10;            if (request.UseChatHtmlParser is not null)&#10;                Config.UseChatHtmlParser = request.UseChatHtmlParser.Value;&#10;            if (request.UseChatOgParser is not null)&#10;                Config.UseChatOgParser = request.UseChatOgParser.Value;&#10;            &#10;            return NoContent();&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Microsoft.AspNetCore.Mvc;&#10;using NoMercyBot.Globals.Information;&#10;using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using NoMercyBot.Api.Helpers;&#10;using NoMercyBot.Database;&#10;using NoMercyBot.Database.Models;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace NoMercyBot.Api.Controllers&#10;{&#10;    [ApiController]&#10;    [Route(&quot;api/[controller]&quot;)]&#10;    public class ConfigController : ControllerBase&#10;    {&#10;        [HttpGet]&#10;        public async Task&lt;IActionResult&gt; GetConfig()&#10;        {&#10;            var config = new&#10;            {&#10;                Config.DnsServer,&#10;                Config.UserAgent,&#10;                Config.InternalServerPort,&#10;                Config.InternalClientPort,&#10;                Config.Swagger,&#10;                Config.QueueWorkers,&#10;                Config.CronWorkers,&#10;                Config.UseTts,&#10;                Config.SaveTtsToDisk,&#10;                Config.UseFrankerfacezEmotes,&#10;                Config.UseBttvEmotes,&#10;                Config.UseSevenTvEmotes,&#10;                Config.UseChatCodeSnippets,&#10;                Config.UseChatHtmlParser,&#10;                Config.UseChatOgParser&#10;            };&#10;            return Ok(config);&#10;        }&#10;&#10;        public class ConfigUpdateRequest&#10;        {&#10;            public int? QueueWorkers { get; set; }&#10;            public int? CronWorkers { get; set; }&#10;            public bool? UseTts { get; set; }&#10;            public bool? SaveTtsToDisk { get; set; }&#10;            public bool? UseFrankerfacezEmotes { get; set; }&#10;            public bool? UseBttvEmotes { get; set; }&#10;            public bool? UseSevenTvEmotes { get; set; }&#10;            public bool? UseChatCodeSnippets { get; set; }&#10;            public bool? UseChatHtmlParser { get; set; }&#10;            public bool? UseChatOgParser { get; set; }&#10;        }&#10;&#10;        [HttpPut]&#10;        public async Task&lt;IActionResult&gt; UpdateConfig([FromBody] ConfigUpdateRequest request)&#10;        {&#10;            int userId = User.UserId();&#10;            await using var db = new AppDbContext();&#10;            if (request.QueueWorkers is not null)&#10;            {&#10;                Config.QueueWorkers = new(Config.QueueWorkers.Key, (int)request.QueueWorkers);&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;QueueWorkers&quot;, Value = request.QueueWorkers.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;                // await QueueRunner.SetWorkerCount(Config.QueueWorkers.Key, (int)request.QueueWorkers, userId);&#10;            }&#10;            if (request.CronWorkers is not null)&#10;            {&#10;                Config.CronWorkers = new(Config.CronWorkers.Key, (int)request.CronWorkers);&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;CronWorkers&quot;, Value = request.CronWorkers.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;                // await QueueRunner.SetWorkerCount(Config.CronWorkers.Key, (int)request.CronWorkers, userId);&#10;            }&#10;            if (request.UseTts is not null)&#10;            {&#10;                Config.UseTts = request.UseTts.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;UseTts&quot;, Value = request.UseTts.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            if (request.SaveTtsToDisk is not null)&#10;            {&#10;                Config.SaveTtsToDisk = request.SaveTtsToDisk.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;SaveTtsToDisk&quot;, Value = request.SaveTtsToDisk.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            if (request.UseFrankerfacezEmotes is not null)&#10;            {&#10;                Config.UseFrankerfacezEmotes = request.UseFrankerfacezEmotes.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;UseFrankerfacezEmotes&quot;, Value = request.UseFrankerfacezEmotes.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            if (request.UseBttvEmotes is not null)&#10;            {&#10;                Config.UseBttvEmotes = request.UseBttvEmotes.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;UseBttvEmotes&quot;, Value = request.UseBttvEmotes.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            if (request.UseSevenTvEmotes is not null)&#10;            {&#10;                Config.UseSevenTvEmotes = request.UseSevenTvEmotes.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;UseSevenTvEmotes&quot;, Value = request.UseSevenTvEmotes.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            if (request.UseChatCodeSnippets is not null)&#10;            {&#10;                Config.UseChatCodeSnippets = request.UseChatCodeSnippets.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;UseChatCodeSnippets&quot;, Value = request.UseChatCodeSnippets.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            if (request.UseChatHtmlParser is not null)&#10;            {&#10;                Config.UseChatHtmlParser = request.UseChatHtmlParser.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;UseChatHtmlParser&quot;, Value = request.UseChatHtmlParser.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            if (request.UseChatOgParser is not null)&#10;            {&#10;                Config.UseChatOgParser = request.UseChatOgParser.Value;&#10;                await db.Configurations.Upsert(new Configuration { Key = &quot;UseChatOgParser&quot;, Value = request.UseChatOgParser.Value.ToString() })&#10;                    .On(c =&gt; c.Key)&#10;                    .WhenMatched((oldConfig, newConfig) =&gt; new Configuration { Value = newConfig.Value })&#10;                    .RunAsync();&#10;            }&#10;            await db.SaveChangesAsync();&#10;            return NoContent();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/NoMercyBot.Server/UserSettings.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/NoMercyBot.Server/UserSettings.cs" />
              <option name="originalContent" value="using NoMercyBot.Database;&#10;using NoMercyBot.Database.Models;&#10;using NoMercyBot.Globals.Extensions;&#10;using NoMercyBot.Globals.Information;&#10;using NoMercyBot.Globals.SystemCalls;&#10;&#10;namespace NoMercyBot.Server;&#10;&#10;public static class UserSettings&#10;{&#10;    public static bool TryGetUserSettings(out Dictionary&lt;string, string&gt; settings)&#10;    {&#10;        settings = new();&#10;&#10;        try&#10;        {&#10;            using AppDbContext context = new();&#10;            List&lt;Configuration&gt; configuration = context.Configurations&#10;                .Where(configuration =&gt; string.IsNullOrWhiteSpace(configuration.SecureValue) &amp;&amp; string.IsNullOrEmpty(configuration.Value))&#10;                .ToList();&#10;&#10;            foreach (Configuration? config in configuration) settings[config.Key] = config.Value;&#10;&#10;            return true;&#10;        }&#10;        catch (Exception)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public static void ApplySettings(Dictionary&lt;string, string&gt; settings)&#10;    {&#10;        foreach (KeyValuePair&lt;string, string&gt; setting in settings)&#10;        {&#10;            Logger.App($&quot;Configuration: {setting.Key} = {setting.Value}&quot;);&#10;            switch (setting.Key)&#10;            {&#10;                case &quot;internalPort&quot;:&#10;                    Config.InternalServerPort = int.Parse(setting.Value);&#10;                    break;&#10;                case &quot;queueRunners&quot;:&#10;                    Config.QueueWorkers = new(Config.QueueWorkers.Key, setting.Value.ToInt());&#10;                    break;&#10;                case &quot;cronRunners&quot;:&#10;                    Config.CronWorkers = new(Config.CronWorkers.Key, setting.Value.ToInt());&#10;                    break;&#10;                case &quot;swagger&quot;:&#10;                    Config.Swagger = setting.Value.ToBoolean();&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using NoMercyBot.Database;&#10;using NoMercyBot.Database.Models;&#10;using NoMercyBot.Globals.Extensions;&#10;using NoMercyBot.Globals.Information;&#10;using NoMercyBot.Globals.SystemCalls;&#10;&#10;namespace NoMercyBot.Server;&#10;&#10;public static class UserSettings&#10;{&#10;    public static bool TryGetUserSettings(out Dictionary&lt;string, string&gt; settings)&#10;    {&#10;        settings = new();&#10;&#10;        try&#10;        {&#10;            using AppDbContext context = new();&#10;            List&lt;Configuration&gt; configuration = context.Configurations&#10;                .Where(configuration =&gt; string.IsNullOrWhiteSpace(configuration.SecureValue) &amp;&amp; string.IsNullOrEmpty(configuration.Value))&#10;                .ToList();&#10;&#10;            foreach (Configuration? config in configuration) settings[config.Key] = config.Value;&#10;&#10;            return true;&#10;        }&#10;        catch (Exception)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public static void ApplySettings(Dictionary&lt;string, string&gt; settings)&#10;    {&#10;        foreach (KeyValuePair&lt;string, string&gt; setting in settings)&#10;        {&#10;            Logger.App($&quot;Configuration: {setting.Key} = {setting.Value}&quot;);&#10;            switch (setting.Key)&#10;            {&#10;                case &quot;internalPort&quot;:&#10;                    Config.InternalServerPort = int.Parse(setting.Value);&#10;                    break;&#10;                case &quot;queueRunners&quot;:&#10;                    Config.QueueWorkers = new(Config.QueueWorkers.Key, setting.Value.ToInt());&#10;                    break;&#10;                case &quot;cronRunners&quot;:&#10;                    Config.CronWorkers = new(Config.CronWorkers.Key, setting.Value.ToInt());&#10;                    break;&#10;                case &quot;swagger&quot;:&#10;                    Config.Swagger = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;DnsServer&quot;:&#10;                    // Config.DnsServer is readonly, cannot set&#10;                    break;&#10;                case &quot;InternalClientPort&quot;:&#10;                    Config.InternalClientPort = int.Parse(setting.Value);&#10;                    break;&#10;                case &quot;QueueWorkers&quot;:&#10;                    Config.QueueWorkers = new(Config.QueueWorkers.Key, setting.Value.ToInt());&#10;                    break;&#10;                case &quot;CronWorkers&quot;:&#10;                    Config.CronWorkers = new(Config.CronWorkers.Key, setting.Value.ToInt());&#10;                    break;&#10;                case &quot;UseTts&quot;:&#10;                    Config.UseTts = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;SaveTtsToDisk&quot;:&#10;                    Config.SaveTtsToDisk = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;UseFrankerfacezEmotes&quot;:&#10;                    Config.UseFrankerfacezEmotes = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;UseBttvEmotes&quot;:&#10;                    Config.UseBttvEmotes = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;UseSevenTvEmotes&quot;:&#10;                    Config.UseSevenTvEmotes = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;UseChatCodeSnippets&quot;:&#10;                    Config.UseChatCodeSnippets = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;UseChatHtmlParser&quot;:&#10;                    Config.UseChatHtmlParser = setting.Value.ToBoolean();&#10;                    break;&#10;                case &quot;UseChatOgParser&quot;:&#10;                    Config.UseChatOgParser = setting.Value.ToBoolean();&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/NoMercyBot.Services/Twitch/TwitchAuthService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/NoMercyBot.Services/Twitch/TwitchAuthService.cs" />
              <option name="originalContent" value="// ReSharper disable MemberCanBePrivate.Global&#10;// ReSharper disable MemberCanBeMadeStatic.Global&#10;&#10;using System.Collections.Specialized;&#10;using System.Web;&#10;using Microsoft.AspNetCore.Http;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Logging;&#10;using NoMercyBot.Database;&#10;using NoMercyBot.Database.Models;&#10;using NoMercyBot.Globals.NewtonSoftConverters;&#10;using NoMercyBot.Services.Interfaces;&#10;using NoMercyBot.Services.Twitch.Dto;&#10;using RestSharp;&#10;&#10;namespace NoMercyBot.Services.Twitch;&#10;&#10;public class TwitchAuthService : IAuthService&#10;{&#10;    private readonly IServiceScope _scope;&#10;    private readonly AppDbContext _dbContext;&#10;    private readonly IConfiguration _conf;&#10;    private readonly ILogger&lt;TwitchAuthService&gt; _logger;&#10;    private readonly TwitchApiService _twitchApiService;&#10;&#10;    public Service Service =&gt; TwitchConfig.Service();&#10;    &#10;    public string ClientId =&gt; Service.ClientId ?? throw new InvalidOperationException(&quot;Twitch ClientId is not set.&quot;);&#10;    private string ClientSecret =&gt; Service.ClientSecret ?? throw new InvalidOperationException(&quot;Twitch ClientSecret is not set.&quot;);&#10;    private string[] Scopes =&gt; Service.Scopes ?? throw new InvalidOperationException(&quot;Twitch Scopes are not set.&quot;);&#10;    public string UserId =&gt; Service.UserId ?? throw new InvalidOperationException(&quot;Twitch UserId is not set.&quot;);&#10;    public string UserName =&gt; Service.UserName ?? throw new InvalidOperationException(&quot;Twitch UserName is not set.&quot;);&#10;    public Dictionary&lt;string, string&gt; AvailableScopes =&gt; TwitchConfig.AvailableScopes ?? throw new InvalidOperationException(&quot;Twitch Scopes are not set.&quot;);&#10;    &#10;    public TwitchAuthService(IServiceScopeFactory serviceScopeFactory, IConfiguration conf, ILogger&lt;TwitchAuthService&gt; logger, TwitchApiService twitchApiService)&#10;    {&#10;        _scope = serviceScopeFactory.CreateScope();&#10;        _dbContext = _scope.ServiceProvider.GetRequiredService&lt;AppDbContext&gt;();&#10;        _conf = conf;&#10;        _logger = logger;&#10;        _twitchApiService = twitchApiService;&#10;    }&#10;&#10;    public async Task&lt;(User, TokenResponse)&gt; Callback(string code)&#10;    {        &#10;        RestClient restClient = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;                    request.AddParameter(&quot;code&quot;, code);&#10;                    request.AddParameter(&quot;scope&quot;, string.Join(' ', Scopes));&#10;                    request.AddParameter(&quot;grant_type&quot;, &quot;authorization_code&quot;);&#10;                    request.AddParameter(&quot;redirect_uri&quot;, TwitchConfig.RedirectUri);&#10;&#10;        RestResponse response = await restClient.ExecuteAsync(request);&#10;&#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;        &#10;        TokenResponse? tokenResponse = response.Content.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;        &#10;        User user = await _twitchApiService.FetchUser(tokenResponse);&#10;        &#10;        await StoreTokens(tokenResponse, user);&#10;&#10;        return (user, tokenResponse);&#10;    }&#10;    &#10;    public Task&lt;(User, TokenResponse)&gt; ValidateToken(HttpRequest request)&#10;    {        &#10;        string authorizationHeader = request.Headers[&quot;Authorization&quot;].First() ?? throw new InvalidOperationException();&#10;        string accessToken = authorizationHeader[&quot;Bearer &quot;.Length..];&#10;        &#10;        return ValidateToken(accessToken);&#10;    }&#10;&#10;    public async Task&lt;(User, TokenResponse)&gt; ValidateToken(string accessToken)&#10;    {&#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        RestRequest request = new(&quot;validate&quot;);&#10;                    request.AddHeader(&quot;Authorization&quot;, $&quot;Bearer {accessToken}&quot;);&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null)&#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;            &#10;        TokenResponse? tokenResponse = response.Content.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        Service service = await _dbContext.Services&#10;            .AsNoTracking()&#10;            .FirstOrDefaultAsync(s =&gt; s.Name == Service.Name)&#10;            ?? throw new InvalidOperationException($&quot;_service {Service.Name} not found in database.&quot;);&#10;&#10;        return (new(), new()&#10;        {&#10;            AccessToken = service.AccessToken,&#10;            RefreshToken = service.RefreshToken,&#10;            ExpiresIn = (int)(service.TokenExpiry - DateTime.UtcNow).Value.TotalSeconds,&#10;        });&#10;    }&#10;&#10;    public async Task&lt;(User, TokenResponse)&gt; RefreshToken(string refreshToken)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;                    request.AddParameter(&quot;refresh_token&quot;, refreshToken);&#10;                    request.AddParameter(&quot;grant_type&quot;, &quot;refresh_token&quot;);&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null)&#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;&#10;        TokenResponse? tokenResponse = response.Content?.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return (new(), tokenResponse);&#10;    }&#10;    &#10;    public async Task RevokeToken(string accessToken)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;revoke&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;token&quot;, accessToken);&#10;                    request.AddParameter(&quot;token_type_hint&quot;, &quot;access_token&quot;);&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null)&#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;    }&#10;    &#10;    public string GetRedirectUrl()&#10;    {        &#10;        NameValueCollection query = HttpUtility.ParseQueryString(string.Empty);&#10;                            query.Add(&quot;response_type&quot;, &quot;code&quot;);&#10;                            query.Add(&quot;client_id&quot;, ClientId);&#10;                            query.Add(&quot;redirect_uri&quot;, TwitchConfig.RedirectUri);&#10;                            query.Add(&quot;scope&quot;, string.Join(' ', Scopes));&#10;                            // query.Add(&quot;force_verify&quot;, &quot;true&quot;);&#10;        &#10;        UriBuilder uriBuilder = new(TwitchConfig.AuthUrl + &quot;/authorize&quot;)&#10;        {&#10;            Query = query.ToString(),&#10;            Scheme = Uri.UriSchemeHttps,&#10;        };&#10;        &#10;        return uriBuilder.ToString();&#10;    }&#10;&#10;    public async Task&lt;DeviceCodeResponse&gt; Authorize(string[]? scopes = null)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;device&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;scopes&quot;, string.Join(' ', scopes ?? Scopes));&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        &#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch device code from Twitch.&quot;);&#10;&#10;        DeviceCodeResponse? deviceCodeResponse = response.Content.FromJson&lt;DeviceCodeResponse&gt;();&#10;        if (deviceCodeResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return deviceCodeResponse;&#10;    }&#10;&#10;    public async Task&lt;TokenResponse&gt; PollForToken(string deviceCode)&#10;    {        &#10;        RestClient restClient = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;                    request.AddParameter(&quot;grant_type&quot;, &quot;urn:ietf:params:oauth:grant-type:device_code&quot;);&#10;                    request.AddParameter(&quot;device_code&quot;, deviceCode);&#10;                    request.AddParameter(&quot;scopes&quot;, string.Join(' ', Scopes));&#10;&#10;        RestResponse response = await restClient.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;&#10;        TokenResponse? tokenResponse = response.Content.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return tokenResponse;&#10;    }&#10;&#10;    internal async Task&lt;TokenResponse&gt; BotToken()&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;        request.AddParameter(&quot;client_id&quot;, ClientId);&#10;        request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;        request.AddParameter(&quot;grant_type&quot;, &quot;client_credentials&quot;);&#10;        request.AddParameter(&quot;scope&quot;, string.Join(' ', Scopes));&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful) throw new(&quot;Failed to fetch bot token.&quot;);&#10;&#10;        TokenResponse? botToken = response.Content?.FromJson&lt;TokenResponse&gt;();&#10;        if (botToken is null) throw new(&quot;Failed to parse bot token.&quot;);&#10;&#10;        return botToken;&#10;    }&#10;    &#10;    public async Task StoreTokens(TokenResponse tokenResponse, User user)&#10;    {&#10;        Service updateService = new()&#10;        {&#10;            Name = Service.Name,&#10;            AccessToken = tokenResponse.AccessToken,&#10;            RefreshToken = tokenResponse.RefreshToken,&#10;            TokenExpiry = DateTime.UtcNow.AddSeconds(tokenResponse.ExpiresIn),&#10;            UserId = user.Id,&#10;            UserName = user.Username&#10;        };&#10;&#10;        AppDbContext dbContext = new();&#10;        await dbContext.Services.Upsert(updateService)&#10;            .On(u =&gt; u.Name)&#10;            .WhenMatched((oldUser, newUser) =&gt; new()&#10;            {&#10;                AccessToken = newUser.AccessToken,&#10;                RefreshToken = newUser.RefreshToken,&#10;                TokenExpiry = newUser.TokenExpiry,&#10;                UserId = newUser.UserId,&#10;                UserName = newUser.UserName,&#10;                UpdatedAt = DateTime.UtcNow,&#10;            })&#10;            .RunAsync();&#10;    &#10;        Service.AccessToken = updateService.AccessToken;&#10;        Service.RefreshToken = updateService.RefreshToken;&#10;        Service.TokenExpiry = updateService.TokenExpiry;&#10;        Service.UserId = updateService.UserId;&#10;        Service.UserName = updateService.UserName;&#10;    }&#10;&#10;    public async Task&lt;bool&gt; ConfigureService(ProviderConfigRequest config)&#10;    {&#10;        try&#10;        {&#10;            // Find existing service or create new one&#10;            Service service = await _dbContext.Services&#10;                .FirstAsync(s =&gt; s.Name == &quot;Twitch&quot;);&#10;&#10;            // Update the configuration&#10;            service.ClientId = config.ClientId;&#10;            service.ClientSecret = config.ClientSecret;&#10;            service.Scopes = config.Scopes;&#10;            service.Enabled = true;&#10;&#10;            _dbContext.Services.Update(service);&#10;&#10;            await _dbContext.SaveChangesAsync();&#10;&#10;            // Update the static reference&#10;            TwitchConfig._service = service;&#10;&#10;            _logger.LogInformation(&quot;Twitch service configured successfully&quot;);&#10;            return true;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(&quot;Failed to configure Twitch service: {Error}&quot;, ex.Message);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public string GetRedirectUrlWithScopes(string[] specificScopes)&#10;    {        &#10;        NameValueCollection query = HttpUtility.ParseQueryString(string.Empty);&#10;                            query.Add(&quot;response_type&quot;, &quot;code&quot;);&#10;                            query.Add(&quot;client_id&quot;, ClientId);&#10;                            query.Add(&quot;redirect_uri&quot;, TwitchConfig.RedirectUri);&#10;                            query.Add(&quot;scope&quot;, string.Join(' ', specificScopes));&#10;                            query.Add(&quot;force_verify&quot;, &quot;true&quot;);&#10;        &#10;        UriBuilder uriBuilder = new(TwitchConfig.AuthUrl + &quot;/authorize&quot;)&#10;        {&#10;            Query = query.ToString(),&#10;            Scheme = Uri.UriSchemeHttps,&#10;        };&#10;        &#10;        return uriBuilder.ToString();&#10;    }&#10;&#10;    // Method to authorize with specific scopes (used by BotAuthService)&#10;    public async Task&lt;DeviceCodeResponse&gt; AuthorizeWithScopes(string[] specificScopes)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;device&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;scopes&quot;, string.Join(' ', specificScopes));&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        &#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch device code from Twitch.&quot;);&#10;&#10;        DeviceCodeResponse? deviceCodeResponse = response.Content.FromJson&lt;DeviceCodeResponse&gt;();&#10;        if (deviceCodeResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return deviceCodeResponse;&#10;    }&#10;}" />
              <option name="updatedContent" value="// ReSharper disable MemberCanBePrivate.Global&#10;// ReSharper disable MemberCanBeMadeStatic.Global&#10;&#10;using System.Collections.Specialized;&#10;using System.Web;&#10;using Microsoft.AspNetCore.Http;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Logging;&#10;using NoMercyBot.Database;&#10;using NoMercyBot.Database.Models;&#10;using NoMercyBot.Globals.NewtonSoftConverters;&#10;using NoMercyBot.Services.Interfaces;&#10;using NoMercyBot.Services.Twitch.Dto;&#10;using RestSharp;&#10;&#10;namespace NoMercyBot.Services.Twitch;&#10;&#10;public class TwitchAuthService : IAuthService&#10;{&#10;    private readonly IServiceScope _scope;&#10;    private readonly AppDbContext _dbContext;&#10;    private readonly IConfiguration _conf;&#10;    private readonly ILogger&lt;TwitchAuthService&gt; _logger;&#10;    private readonly TwitchApiService _twitchApiService;&#10;&#10;    public Service Service =&gt; TwitchConfig.Service();&#10;    &#10;    public string ClientId =&gt; Service.ClientId ?? throw new InvalidOperationException(&quot;Twitch ClientId is not set.&quot;);&#10;    private string ClientSecret =&gt; Service.ClientSecret ?? throw new InvalidOperationException(&quot;Twitch ClientSecret is not set.&quot;);&#10;    private string[] Scopes =&gt; Service.Scopes ?? throw new InvalidOperationException(&quot;Twitch Scopes are not set.&quot;);&#10;    public string UserId =&gt; Service.UserId ?? throw new InvalidOperationException(&quot;Twitch UserId is not set.&quot;);&#10;    public string UserName =&gt; Service.UserName ?? throw new InvalidOperationException(&quot;Twitch UserName is not set.&quot;);&#10;    public Dictionary&lt;string, string&gt; AvailableScopes =&gt; TwitchConfig.AvailableScopes ?? throw new InvalidOperationException(&quot;Twitch Scopes are not set.&quot;);&#10;    &#10;    public TwitchAuthService(IServiceScopeFactory serviceScopeFactory, IConfiguration conf, ILogger&lt;TwitchAuthService&gt; logger, TwitchApiService twitchApiService)&#10;    {&#10;        _scope = serviceScopeFactory.CreateScope();&#10;        _dbContext = _scope.ServiceProvider.GetRequiredService&lt;AppDbContext&gt;();&#10;        _conf = conf;&#10;        _logger = logger;&#10;        _twitchApiService = twitchApiService;&#10;    }&#10;&#10;    public async Task&lt;(User, TokenResponse)&gt; Callback(string code)&#10;    {        &#10;        RestClient restClient = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;                    request.AddParameter(&quot;code&quot;, code);&#10;                    request.AddParameter(&quot;scope&quot;, string.Join(' ', Scopes));&#10;                    request.AddParameter(&quot;grant_type&quot;, &quot;authorization_code&quot;);&#10;                    request.AddParameter(&quot;redirect_uri&quot;, TwitchConfig.RedirectUri);&#10;&#10;        RestResponse response = await restClient.ExecuteAsync(request);&#10;&#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;        &#10;        TokenResponse? tokenResponse = response.Content.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;        &#10;        User user = await _twitchApiService.FetchUser(tokenResponse);&#10;        &#10;        await StoreTokens(tokenResponse, user);&#10;&#10;        return (user, tokenResponse);&#10;    }&#10;    &#10;    public Task&lt;(User, TokenResponse)&gt; ValidateToken(HttpRequest request)&#10;    {        &#10;        string authorizationHeader = request.Headers[&quot;Authorization&quot;].First() ?? throw new InvalidOperationException();&#10;        string accessToken = authorizationHeader[&quot;Bearer &quot;.Length..];&#10;        &#10;        return ValidateToken(accessToken);&#10;    }&#10;&#10;    public async Task&lt;(User, TokenResponse)&gt; ValidateToken(string accessToken)&#10;    {&#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        RestRequest request = new(&quot;validate&quot;);&#10;                    request.AddHeader(&quot;Authorization&quot;, $&quot;Bearer {accessToken}&quot;);&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null)&#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;            &#10;        TokenResponse? tokenResponse = response.Content.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        Service service = await _dbContext.Services&#10;            .AsNoTracking()&#10;            .FirstOrDefaultAsync(s =&gt; s.Name == Service.Name)&#10;            ?? throw new InvalidOperationException($&quot;_service {Service.Name} not found in database.&quot;);&#10;&#10;        return (new(), new()&#10;        {&#10;            AccessToken = service.AccessToken,&#10;            RefreshToken = service.RefreshToken,&#10;            ExpiresIn = (int)(service.TokenExpiry - DateTime.UtcNow).Value.TotalSeconds,&#10;        });&#10;    }&#10;&#10;    public async Task&lt;(User, TokenResponse)&gt; RefreshToken(string refreshToken)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;                    request.AddParameter(&quot;refresh_token&quot;, refreshToken);&#10;                    request.AddParameter(&quot;grant_type&quot;, &quot;refresh_token&quot;);&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null)&#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;&#10;        TokenResponse? tokenResponse = response.Content?.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return (new(), tokenResponse);&#10;    }&#10;    &#10;    public async Task RevokeToken(string accessToken)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;revoke&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;token&quot;, accessToken);&#10;                    request.AddParameter(&quot;token_type_hint&quot;, &quot;access_token&quot;);&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null)&#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;    }&#10;    &#10;    public string GetRedirectUrl()&#10;    {        &#10;        NameValueCollection query = HttpUtility.ParseQueryString(string.Empty);&#10;                            query.Add(&quot;response_type&quot;, &quot;code&quot;);&#10;                            query.Add(&quot;client_id&quot;, ClientId);&#10;                            query.Add(&quot;redirect_uri&quot;, TwitchConfig.RedirectUri);&#10;                            query.Add(&quot;scope&quot;, string.Join(' ', Scopes));&#10;                            // query.Add(&quot;force_verify&quot;, &quot;true&quot;);&#10;        &#10;        UriBuilder uriBuilder = new(TwitchConfig.AuthUrl + &quot;/authorize&quot;)&#10;        {&#10;            Query = query.ToString(),&#10;            Scheme = Uri.UriSchemeHttps,&#10;        };&#10;        &#10;        return uriBuilder.ToString();&#10;    }&#10;&#10;    public async Task&lt;DeviceCodeResponse&gt; Authorize(string[]? scopes = null)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;device&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;scopes&quot;, string.Join(' ', scopes ?? Scopes));&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        &#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch device code from Twitch.&quot;);&#10;&#10;        DeviceCodeResponse? deviceCodeResponse = response.Content.FromJson&lt;DeviceCodeResponse&gt;();&#10;        if (deviceCodeResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return deviceCodeResponse;&#10;    }&#10;&#10;    public async Task&lt;TokenResponse&gt; PollForToken(string deviceCode)&#10;    {        &#10;        RestClient restClient = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;                    request.AddParameter(&quot;grant_type&quot;, &quot;urn:ietf:params:oauth:grant-type:device_code&quot;);&#10;                    request.AddParameter(&quot;device_code&quot;, deviceCode);&#10;                    request.AddParameter(&quot;scopes&quot;, string.Join(' ', Scopes));&#10;&#10;        RestResponse response = await restClient.ExecuteAsync(request);&#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch token from Twitch.&quot;);&#10;&#10;        TokenResponse? tokenResponse = response.Content.FromJson&lt;TokenResponse&gt;();&#10;        if (tokenResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return tokenResponse;&#10;    }&#10;&#10;    internal async Task&lt;TokenResponse&gt; BotToken()&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        RestRequest request = new(&quot;token&quot;, Method.Post);&#10;        request.AddParameter(&quot;client_id&quot;, ClientId);&#10;        request.AddParameter(&quot;client_secret&quot;, ClientSecret);&#10;        request.AddParameter(&quot;grant_type&quot;, &quot;client_credentials&quot;);&#10;        request.AddParameter(&quot;scope&quot;, string.Join(' ', Scopes));&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        if (!response.IsSuccessful) throw new(&quot;Failed to fetch bot token.&quot;);&#10;&#10;        TokenResponse? botToken = response.Content?.FromJson&lt;TokenResponse&gt;();&#10;        if (botToken is null) throw new(&quot;Failed to parse bot token.&quot;);&#10;&#10;        return botToken;&#10;    }&#10;    &#10;    public async Task StoreTokens(TokenResponse tokenResponse, User user)&#10;    {&#10;        // Always check the database for the current user before overwriting tokens&#10;        var existingService = await _dbContext.Services.AsNoTracking().FirstOrDefaultAsync(s =&gt; s.Name == Service.Name);&#10;        if (existingService != null &amp;&amp; !string.IsNullOrEmpty(existingService.UserId) &amp;&amp; existingService.UserId != user.Id)&#10;        {&#10;            _logger.LogWarning(&quot;Attempt to overwrite Twitch provider tokens for {Provider} with a different user. Existing: {ExistingUserId}, Incoming: {IncomingUserId}&quot;, Service.Name, &quot;REDACTED&quot;, &quot;REDACTED&quot;);&#10;            throw new InvalidOperationException($&quot;This provider is already linked to a different user. Please log out first or contact an admin.&quot;);&#10;        }&#10;&#10;        Service updateService = new()&#10;        {&#10;            Name = Service.Name,&#10;            AccessToken = tokenResponse.AccessToken,&#10;            RefreshToken = tokenResponse.RefreshToken,&#10;            TokenExpiry = DateTime.UtcNow.AddSeconds(tokenResponse.ExpiresIn),&#10;            UserId = user.Id,&#10;            UserName = user.Username&#10;        };&#10;&#10;        await _dbContext.Services.Upsert(updateService)&#10;            .On(u =&gt; u.Name)&#10;            .WhenMatched((oldUser, newUser) =&gt; new()&#10;            {&#10;                AccessToken = newUser.AccessToken,&#10;                RefreshToken = newUser.RefreshToken,&#10;                TokenExpiry = newUser.TokenExpiry,&#10;                UserId = newUser.UserId,&#10;                UserName = newUser.UserName,&#10;                UpdatedAt = DateTime.UtcNow,&#10;            })&#10;            .RunAsync();&#10;    &#10;        Service.AccessToken = updateService.AccessToken;&#10;        Service.RefreshToken = updateService.RefreshToken;&#10;        Service.TokenExpiry = updateService.TokenExpiry;&#10;        Service.UserId = updateService.UserId;&#10;        Service.UserName = updateService.UserName;&#10;    }&#10;&#10;    public async Task&lt;bool&gt; ConfigureService(ProviderConfigRequest config)&#10;    {&#10;        try&#10;        {&#10;            // Find existing service or create new one&#10;            Service service = await _dbContext.Services&#10;                .FirstAsync(s =&gt; s.Name == &quot;Twitch&quot;);&#10;&#10;            // Update the configuration&#10;            service.ClientId = config.ClientId;&#10;            service.ClientSecret = config.ClientSecret;&#10;            service.Scopes = config.Scopes;&#10;            service.Enabled = true;&#10;&#10;            _dbContext.Services.Update(service);&#10;&#10;            await _dbContext.SaveChangesAsync();&#10;&#10;            // Update the static reference&#10;            TwitchConfig._service = service;&#10;&#10;            _logger.LogInformation(&quot;Twitch service configured successfully&quot;);&#10;            return true;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(&quot;Failed to configure Twitch service: {Error}&quot;, ex.Message);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    public string GetRedirectUrlWithScopes(string[] specificScopes)&#10;    {        &#10;        NameValueCollection query = HttpUtility.ParseQueryString(string.Empty);&#10;                            query.Add(&quot;response_type&quot;, &quot;code&quot;);&#10;                            query.Add(&quot;client_id&quot;, ClientId);&#10;                            query.Add(&quot;redirect_uri&quot;, TwitchConfig.RedirectUri);&#10;                            query.Add(&quot;scope&quot;, string.Join(' ', specificScopes));&#10;                            query.Add(&quot;force_verify&quot;, &quot;true&quot;);&#10;        &#10;        UriBuilder uriBuilder = new(TwitchConfig.AuthUrl + &quot;/authorize&quot;)&#10;        {&#10;            Query = query.ToString(),&#10;            Scheme = Uri.UriSchemeHttps,&#10;        };&#10;        &#10;        return uriBuilder.ToString();&#10;    }&#10;&#10;    // Method to authorize with specific scopes (used by BotAuthService)&#10;    public async Task&lt;DeviceCodeResponse&gt; AuthorizeWithScopes(string[] specificScopes)&#10;    {        &#10;        RestClient client = new(TwitchConfig.AuthUrl);&#10;        &#10;        RestRequest request = new(&quot;device&quot;, Method.Post);&#10;                    request.AddParameter(&quot;client_id&quot;, ClientId);&#10;                    request.AddParameter(&quot;scopes&quot;, string.Join(' ', specificScopes));&#10;&#10;        RestResponse response = await client.ExecuteAsync(request);&#10;        &#10;        if (!response.IsSuccessful || response.Content is null) &#10;            throw new(response.Content ?? &quot;Failed to fetch device code from Twitch.&quot;);&#10;&#10;        DeviceCodeResponse? deviceCodeResponse = response.Content.FromJson&lt;DeviceCodeResponse&gt;();&#10;        if (deviceCodeResponse == null) throw new(&quot;Invalid response from Twitch.&quot;);&#10;&#10;        return deviceCodeResponse;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>